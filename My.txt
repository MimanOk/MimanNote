# 安卓之dex文件 #
    dex文件是Android系统bai的可执行文件，包du含应用程序的全部操作指令以及zhi运行时数据。

    由于dalvik是一种针对嵌dao入式设备而特殊设计的java虚拟机，所以dex文件与标准的class文件在结构设计上有着本质的区别。
    当java程序编译成class后，还需要使用dex工具将所有的class文件整合到一个dex文件，目的是其中各个类能够共享数据，在一
    定程度上降低了冗余，同时也是文件结构更加经凑，dex文件是传统jar文件大小的50％左右。
    dex将原来class每个文件都有的共有信息合成一体，这样减少了class的冗余。
    从宏观上来说dex的文件结果很简单，实际上是由多个不同结构的数据体以首尾相接的方式拼接而成。
    

    dex是应用安装时生成的虚拟机可执行二进制文件，du如果应zhi用还存在，删除了下次手机开机时还会再次生成，卸载软件时会
    同时删除dex文件。所以没有必要手动删除dex文件。对于Android DEX文件进行优化，需要注意的一点是DEX文件的结构是紧凑的，
    但是我们还是要想方设法的进行提高程序的运行速度，我们就仍然需要对DEX文件进行进一步优化。调整所有字段的字节序（LITTLE_ENDIAN）
    和对齐结构中的每一个域 验证DEX文件中的所有类 对一些特定的类进行优化，对方法里的操作码进行优化 。优化后的文件大小会有所增加，
    应该是原Android DEX文件的1-4倍。 优化发生的时机有两个：对于预置应用，可以在系统编译后，生成优化文件，以ODEX结尾。
　　这样在发布时除APK文件（不包含DEX）以外，还有一个相应的Android DEX文件；对于非预置应用，包含在APK文件里的DEX文件会在
    运行时被优化，优化后的文件将被保存在缓存中。每一个Android应用都运行在一个Dalvik虚拟机实例里，而每一个虚拟机实例都是
    一个独立的进程空间。虚拟机的线程机制，内存分配和管理，Mutex等等都是依赖底层操作系统而实现的。
    
    扩展资料：
        Android的系统架构和其操作系统一样，采用了分层的架构。
        从架构图看，Android分为四个层，从高层到低层分别是应用程序层、应用程序框架层、系统运行库层和Linux内核层。
        dex文件的作用：
        dex文件的作用是记录整个工程（通常是一个Android工程）的所有类文件的信息。
        dex文件的结构：
        8位字节的二进制流文件；各个数据紧密排列，无间隙，减少了文件体积，加快加载速度；整个工程的类信息都存放在一个
        dex文件中（不考虑dex分包的情况下）；同样地，可以通过010Editor来查看dex文件信息。
# end #

# 安卓之APK反编译 #
    github: https://github.com/pxb1988/dex2jar/releases
    反编译成jar: dex2jar.bat classes.dex
    在jd-gui中显示源码
# end #

# 抓包工具 #
    Burpsuite基于java语言，具有跨平台的优势；

    Fiddler基于.Net，入门简单，功能强大，但是只适用win平台，目前借助mono也无法很好的在mac、linux平台运行；

    Wireshark各平台都有相应版本，不过入门门槛相对较高。
    Burpsuite和Fiddler在抓包上侧重请求和响应的数据，Wireshark侧重于数据帧
# end #

# 完整的HTTP请求会经历以下过程(大佬的理解)#
    当我们在浏览器的地址栏输入 www.linux178.com ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？

    以下过程仅是个人理解：

    Http 的header会给我们的请求包装，比如AF中经常设置的可接受的Accept（text/html） --》域名解析，根据域名找
    到服务器的IP --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html
    代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户

    每次都请求都会经过  客户端的应用层（http协议）-->  客户端的传输层（tcp或udp协议） -->客户端的网络层（ip协议）
    --> 客户端的链路层（网卡，路由器等） -->  ------------------经过dns解析，穿越多个isp（互联网服务提供商，移动，
    联通，电信等），各种数据交换，找到了服务器------------------- 服务器的链路层  -->服务器的网络层  -->服务器的
    传输层  -->服务器的应用层。 这个请求完成了。

    服务器响应  与请求相反，倒过来看即可。
    
# 举个栗子(Google浏览器)
    以下就是上面过程的一一分析，我们就以Chrome浏览器为例：

    1.域名解析（DNS解析）

    首先Chrome浏览器会解析 www.linux178.com 这个域名（准确的叫法应该是主机名）对应的IP地址。怎么解析到对应的IP地址？

    ① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存
    中是否有www.linux178.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。

        注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看

    ② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索
    解析到此结束.

         注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看  

    ③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面
    有没有该域名对应的IP地址，如果有则解析成功。

    ④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电
    信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请
    求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到
    对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首
    先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问ww
    w.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这
    个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了
    请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名
    的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这
    个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候li
    nux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器
    就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了ww
    w.linux178.com  对应的IP地址，该进行一步的动作了。

    注：一般情况下是不会进行以下步骤的

    如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤（以下是针对Windows操作系统）：

    ⑤ 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段
    时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是
    几分钟前和我成功通信过，那么这一步就可以成功解析。

    ⑥ 如果第⑤步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）

    ⑦ 如果第⑥步也没有查询成功，那么客户端就要进行广播查找

    ⑧ 如果第⑦步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）

    如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那
    就可以成功和目标计算机进行通信。
# end #
















