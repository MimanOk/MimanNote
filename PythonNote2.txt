主线任务：
-------------------------------------------------
1、js解密
2、django
<----------------------------------------------->

# 查看系统信息 #
	## 获取系统类型
	 # platform.system()
	## 获取操作系统名称及版本号，'Windows-10-10.0.17134-SP0'
	 # platform.platform()
	## 获取操作系统版本号，'10.0.17134'
	 # platform.version()
	## 获取操作系统的位数，('64bit', 'WindowsPE')
	 # platform.architecture()
	## 计算机硬件架构，'AMD64'
	 # platform.machine()
	## 计算机的网络名称，'TDM'
	 # platform.node()
	## 计算机处理器信息，'Intel64 Family 6 Model 158 Stepping 9, GenuineIntel'
	 # platform.processor()
	## 包含上面所有的信息汇总，
	 # platform.uname()
# end #

# 内置函数 #
-> any()
	- 等价于
	def any(iterable)；
		for element in iterable:
			# 有True则返回True
			if element:
				return True
		return False
		
-> all()
	- 等价于
	def all(iterable):
		for element in iterable:
			# 只要碰到False则返回False
			if not element:
				return False
		return True

# end #

# url编码
  # from urllib.parse import urlencode, quote
    # urlencode
    # quote

-> 判断是否为Unicode编码 -->if isinstance("str", str)

-> json文件保存编码一致
    - with open(..., encoding='utf-8') as f:
        f.write(json.dumps(待保存文件, ensure_ascii=False) + '\n')

-> re模块  # \s* 匹配空格，起到换行作用
    - ip_adress = re.compile(
                '<td class="country"><img src="http://fs.xicidaili.com/images/flag/cn.png" alt="Cn" /></td>\s*<td>(.*?)</td>\s*<td>(.*?)</td>'
            )

-> scrapy中使用FormRequest()来发出带data的请求

# time模块 #
-> 时间类型转换
    - time.strftime("%Y-%m-%d"， time.localtime(time.time() - ...))
-> 获取单个：年月日时分秒
	time.localtime().tm_hour  ->int  # 年:tm_year 月:tm_mon 日:tm_mday 时:tm_hour 分:tm_min 秒:tm_sec
# end #

# datetime模块 #
-> 获取单个：年月日时分秒
	datetime.datetime.now().hour  ->datetime.datetime  # 年:year 月:month 日:day 时:hour 分:minute 秒:second
-> 获取年月日时分秒
    - datetime.datetime.now()
-> 获取年月日
    - datetime.datetime.now().date()
-> 时间类型转换
	- datetime.datetime.now().strftime("%Y-%m-%d")  # -O->2020-04-16
	- datetime.datetime.fromtimestamp(int型时间戳)  # 转换成datetime.datetime型的含六个元素的元组时间格式
	- datetime.datetime.fromtimestamp(int型时间戳).strftime("%Y-%m-%d")  # 转化成指定的格式

# end #

# pyexecel模块 #
	# import pyexecel
	  rows = []
	  rows.append(you_dict)
	  # 保存
	  pyexecel.save_as(records=rows, dest_file_name="%s.xls" % file_name)
# end #

-> 打开图片文件并显示
	- from PIL import Image
	try:
		im = Image.open("image_path_name")
		im.show()
		im.close()
	except Exception:
		pass

# os模块 #

-> 返回命令行结果
res = os.popen("Command").read()

-> 获取文件大小
    - os.stat("文件路径及文件名").st_size
    - os.path.getsize("文件路径及文件名")

-> 获取所有文件
    - os.listdir(file_path)

-> 获取当前工作空间路径
    - os.getcwd()

-> 获取当前py文件路径
    - os.path.abspath(__file__)

-> 获取当前py文件父路径
    - os.path.dirname(os.path.abspath(__file__))
	
# 获取路径中的文件名及后缀
  # os.path.basename("path")

# end #

# signal模块 #
	## 注册中断信号(Ctrl+C停止)，像linux中kill发送的中断信号一样
	 # signal.signal(signal.SIGINT, my_func)  # my_func接收两个参数:(signum, frame)
# end #

# shutil模块 #

-> shutil.move(old_path, new_path)：old_path格式的文件转换为new_path格式的文件

# end #

# sys模块 #

-> 增加环境变量
    - sys.path.append("path")
-> 将路径加到pythonpath当中
	- sys.path.insert(index, "path")  # index：顺序（填0）

# end #

# 线程、进程、协程 #

-> 路径env python版本，可以动态的切换python版本
-> python 的多线程是利用的CPU上下文切换，同一时刻只在一个核上进行操作，实质上还是单线程。
-> python 的IO操作不占用CPU，计算占用CPU。所以python多线程适合密集型IO任务，不适合密集型CPU任务。
-> 线程的进程ID是离发起该线程最近的进程ID，其父进程ID是运行程序员代码的主进程ID
    - 编译器进程（PPID=None，PID=0）---> 运行代码进程（PPID=0, PID=1）---> 程序员发起进程（PPID=1, PID=2）---> A线程（PID=1, PID=2）---> D线程（PID=1, ID=2）

# 线程间通信 #
	## 用queue模块中的Queue实例化一个q然后对该q操作，进程能和其线程能共享q
	## 如果q中put了很多数据共线程get,那么在线程join前要先使用q.join()来使队列清空。
	## 通知队列，数据已经处理，可以删除了
	 # q.task_done()
	## 打印队列长度
	 # q.qsize()
# end #

-> 进程通信用multiprocessing模块中的Queue实例化一个q（父进程克隆出的q）然后要把q传给子进程才能都对q操作，实质上是数据的传递，不是共享数据
-> 要实现进程间数据共享，使用multiprocessing模块中的Manager实例化一个共享空间m，通过其中的m.list(...), m.dict(...)等数据类型来实现数据共享
-> 管道通信用multiprocessing模块中的Pipe实例化两个通信的端口A、B，可以通过端口A.send()发也能A.recv()收，B和A一样
-> multiprocessing模块中的进程锁Lock，用处1：防止多个进程同时占用屏幕，用法和线程锁类似，线实例化一把锁lock，再lock.acquire()和lock.release()
-> 启用一个进程会克隆父进程的数据给子进程用，开销很大，因此有进程池来限制
-> 进程池：multiprocessing模块中的Pool，实例化对象pool时可在Pool中传入一个最大进程数，pool的异步async方法可以传入回调函数
    - 注意：最后必须要先加pool.close()再加pool.join()，顺序不能颠倒
	
	Process()类实例化的进程p独立于主进程，不会因主进程结束而退出。
	Pool()类实例化进程池依赖于主进程，主进程退出，进程池立即退出。
	
-> 守护线程：主线程结束，不管子线程有没有执行完，都将强制结束。用Thread实例化的对象th中的setDaemon(True)来将子线程设置为守护线程。注意要在start之前设置
-> 自定义进程：
	class MyProcess(Process)  #继承Process类
		def __init__(self, *args, **kwargs):
			# 需要出入初始化参数时添加__init__函数
			super(MyProcess, self).__init__()
			self.args = args
		def run(self):
			# do you want
			psss
			
-> 自定义线程：
	# 自定义线程与自定义进程的区别在于继承的是Thread父类
	
-> 创建线程锁时要避免死锁(分配任务不当会造成死锁)，即A线程使用B锁后未释放就交出CPU执行权并进行IO操作，
	同时B线程使用A锁后未释放也交出CPU执行权并进行IO操作。这时A线程处理完IO操作进入等待队列并获取CPU执行权，
	A线程又想使用A锁，但A锁被B线程占用，只被迫能阻塞等待。更巧的是B线程拿到CPU执行权后又想去使用B锁，
	此时B锁被A线程占用，B线程也被迫阻塞等待。那么，现在AB线程都处于阻塞等待状态，如果不在acquire请求锁时
	添加超时参数，那么两个线程将一直阻塞，造成死锁。

-> 协程：
    - greenlet：手动的
	from greenlet import greenlet
		ga = greenlet(func_a)  # func_a:有IO操作的函数
		gb = greenlet(func_b)  # func_b:有IO操作的函数
	在func_a进行IO操作的代码上使用gb.switch()切换到func_b函数，func_b函数同理

    - gevent: 自动的
	import gevent
	from gevent import monkey
	monkey.fatch_all()  # 猴子补丁
	...
	ga = gevent.spawn(func_a, args)
	gb = gevent.spawn(func_b, args)
	ga.join()
	gb.join()

# end #

# 其他 #

-> requests
    - 对于保存响应数据较大的情况(如视频)，应一点一点的对其进行保存：
    for chunk in response.iter_content(1024):
        f.write(chunk)

-> http://httpbin.org/ip            - 请求获取ip
-> http://httpbin.org/cookies     - 请求获取cookie

-> 安装pip
    - python -m pip install pip==9.0.3
	# 清华镜像源
	- pip3 install -r packages.txt -i https://pypi.tuna.tsinghua.edu.cn/simple

-> 配置虚拟环境
    - 1. pip install virtualenv -->virtualenv venv_name -->cd venv_name -->activate.bat -->deactivate.bat
    - 2. python -m venv path\venv_name -->同-1

-> 爬虫去重策略
    - 将访问过的url经md5哈希后保存到set中
    - bloomfilter方法对bitmap（将一条数据通过hash映射到某一位，非常节省内存，但冲突严重）进行改进，多重哈希函数降低冲突

# end #

-> 判断是否以Miman字符串开头："MimanOk".startswith("Miman")
-> 判断是否以Miman字符串结尾："OkMiman".endswith("Miman")

-> 移除网页标签
	- from w3llib.html import remove_tags -->remove_tags("str")
	
# 一个异步io实例 #
import ansycio
class Downloader(object):
    """
    一个异步下载器，可以对代理源异步抓取，但是容易被BAN。
    """

    def __init__(self, urls):
        self.urls = urls
        self._htmls = []

    async def download_single_page(self, url):
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                self._htmls.append(await resp.text())

    def download(self):
        loop = asyncio.get_event_loop()
        tasks = [self.download_single_page(url) for url in self.urls]
        loop.run_until_complete(asyncio.wait(tasks))

    @property
    def htmls(self):
        self.download()
        return self._htmls

# end #

# 断言assert #
	assert expression
	等价于：

	if not expression:
		raise AssertionError
	assert 后面也可以紧跟参数:

	assert expression [, arguments]
	等价于：

	if not expression:
		raise AssertionError(arguments)
	以下为 assert 使用实例：

	>>> assert True     # 条件为 true 正常执行
	>>> assert False    # 条件为 false 触发异常
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	AssertionError
	>>> assert 1==1    # 条件为 true 正常执行
	>>> assert 1==2    # 条件为 false 触发异常
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	AssertionError

	>>> assert 1==2, '1 不等于 2'
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	AssertionError: 1 不等于 2
# end #

if __name__ == '__main__':

	async def eat(food):
		for i in range(1, 3 + 1):
			print("eating->> {food:-<5}".format(food=food))
			await asyncio.sleep(3)
		
# 协程并发1 #
    pool = asyncio.get_event_loop()
    eat1 = eat("辣条")
    eat2 = eat("包子")
    eat3 = eat("烤鸡")

    task = [
        asyncio.ensure_future(eat1),
        asyncio.ensure_future(eat2),
        asyncio.ensure_future(eat3),
    ]

    pool.run_until_complete(asyncio.wait(task))
# end #

# 协程并发2 #
    pool = asyncio.get_event_loop()
    pool.run_until_complete(asyncio.wait([eat(food) for food in {"烤鸡", "包子", "辣条"}]))
# end #

# pickle #
	try:
		import cPickle as pickle
	except ImportError:
		import pickle
		
	def loads(str):
	return pickle.loads(str)
	
	def dumps(obj):
		return pickle.dumps(obj, protocol=-1)
# end #

# __slots__ #
class A():
	"允许该类中存在的属性"
	__slots__ = ("允许的属性1", 允许的属性2)
# end #

# cookiejar登录知乎 #
import re
import requests
import http.cookiejar
from PIL import Image
import time
import json
 
headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 '
                         '(KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36',
           "Host": "www.zhihu.com",
           "Referer": "https://www.zhihu.com/",
           }
# 建立一个会话，可以把同一用户的不同请求联系起来；直到会话结束都会自动处理cookies
session = requests.Session()
# 建立LWPCookieJar实例，可以存Set-Cookie3类型的文件。
# 而MozillaCookieJar类是存为'/.txt'格式的文件
session.cookies = http.cookiejar.LWPCookieJar("cookie")
# 若本地有cookie则不用再post数据了
try:
    session.cookies.load(ignore_discard=True)
except IOError:
    print('Cookie未加载！')
 
 
def get_xsrf():
    """
    获取参数_xsrf
    """
    response = session.get('https://www.zhihu.com', headers=headers)
    html = response.text
    get_xsrf_pattern = re.compile(r'<input type="hidden" name="_xsrf" value="(.*?)"')
    _xsrf = re.findall(get_xsrf_pattern, html)[0]
    return _xsrf
 
 
def get_captcha():
    """
    获取验证码本地显示
    返回你输入的验证码
    """
    t = str(int(time.time() * 1000))
    captcha_url = 'http://www.zhihu.com/captcha.gif?r=' + t + "&type=login"
    response = session.get(captcha_url, headers=headers)
    with open('cptcha.gif', 'wb') as f:
        f.write(response.content)
    # Pillow显示验证码
    im = Image.open('cptcha.gif')
    im.show()
    captcha = input('本次登录需要输入验证码： ')
    return captcha
 
 
def login(username, password):
    """
    输入自己的账号密码，模拟登录知乎
    """
    # 检测到11位数字则是手机登录
    if re.match(r'\d{11}$', username):
        url = 'http://www.zhihu.com/login/phone_num'
        data = {'_xsrf': get_xsrf(),
                'password': password,
                'remember_me': 'true',
                'phone_num': username
                }
    else:
        url = 'https://www.zhihu.com/login/email'
        data = {'_xsrf': get_xsrf(),
                'password': password,
                'remember_me': 'true',
                'email': username
                }
    # 若不用验证码，直接登录
    result = session.post(url, data=data, headers=headers)
    # 打印返回的响应，r = 1代表响应失败，msg里是失败的原因
    # loads可以反序列化内置数据类型，而load可以从文件读取
    if (json.loads(result.text))["r"] == 1:
        # 要用验证码，post后登录
        data['captcha'] = get_captcha()
        result = session.post(url, data=data, headers=headers)
        print((json.loads(result.text))['msg'])
        # 保存cookie到本地
    session.cookies.save(ignore_discard=True, ignore_expires=True)
 
 
def isLogin():
    # 通过查看用户个人信息来判断是否已经登录
    url = "https://www.zhihu.com/settings/profile"
    # 禁止重定向，否则登录失败重定向到首页也是响应200
    login_code = session.get(url, headers=headers, allow_redirects=False).status_code
    if login_code == 200:
        return True
    else:
        return False
 
 
if __name__ == '__main__':
    if isLogin():
        print('您已经登录')
    else:
        account = input('输入账号：')
        secret = input('输入密码：')
        login(account, secret)
# end #

# 解析CSS文件
  # import tinycss
    css_resp = requests.get(url)
    parser = tinycss.make_parser("page3")
	ss = parser.parse_stylesheet(css_resp.text)
	
	for rule in ss.rules:
	    print(rule.selector[1].valie, end=": ")
		for d in rule.declarations:
		    print(d.name, end=" ")
		    for v in d.value:
			    if v.value == " ":
				    continue
			    print(int(v.value), end="px ")
  


















