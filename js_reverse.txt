# time : 2021.03.17
# time_from : 2017.12.13
# author : huoyijun


# js基本知识点
    # js标准分为：ES3、ES5、ES6等
    # ES5里包含JSON函数定义
    # V8引擎是google的一个开源引擎，以ES5为标准
    # 当遇到ES5支持而ES3不支持的函数，可以找到该函数源码直接替换该函数来实现调用
    # window.btoa  # 浏览器特有的base64编码,如需使用，可以将base64源码复制过来
    ## 匿名函数自动调用
        # (function(){}(arg));
        # (function(){})(arg);
        # !function(){}(arg);
        # 匿名函数嵌入在两个逗号间，感叹号省略也会自动执行
    ## 加密方法
        # MD5  # hash加密
        # AES/DES  # 对称加密
        # RSA  # 非对称加密，每次加密后的结果都不一样
        # Base64  # 伪加密，属于编码，编码后的伪密文结尾一般带: "=="
    # 对象的数据属性
        Object.defineProperty(person,'name',{
            configurable:false,//能否使用delete、能否需改属性特性、或能否修改访问器属性，false为不可重新定义，默认值为true
            enumerable:false,//对象属性是否可通过for-in循环，flase为不可循环，默认值为true
            writable:false,//对象属性是否可修改,flase为不可修改，默认值为true
            value:'xiaoming' //对象属性的默认值，默认值为undefined
        });

# JS常用加密与相应解密方法
    ## MD5
        ### 加密
            <html>
                <script scr="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
                <script type="text/javascript">
                    var hashCode = md5("huoyijun");
                    alert(hashCode)
                </script>
            </html>
            
        ### 解密
            不能直接解密，只能正向暴力破解。为了提高数据安全性，一般会将明文进行三次md5
            加密，所以很难解密，建议放弃。
            
    ## AES/DES对称加密
        <html>
            <script scr="https://cdn.bootcss.com/crypto-js.js"></script>
            <script type="text/javascript">
                var key = "12345678"  // 定制密钥，长度必须是：8/16/32位
                var data = "待加密数据"
                // AES/DES加密只需要切换CryptoJS.AES <=>CryptoJS.DES
                var encrypt = CryptoJS.AES.encrypt(data, CryptoJS.enc.utf8.parse(key), {
                    mode: CryptoJS.mode.ECB,  // 工作方式
                    padding: CryptoJS.pad.Pkcs7  // 填充模式，待加密数据必须为8的倍数，不然就进行该方式的填充
                }).toString();
                alert(encrypt);
                
                // 解密
                var decrypt = CryptoJS.AES.decrypt(data, CryptoJS.enc.utf8.parse(key), {
                    mode: CryptoJS.mode.ECB,
                    padding: CryptoJS.pad.Pkcs7
                }).toString(CryptoJS.enc.utf8);
                alert(decrypt);
            </script>
        </html>
        
    ## RSA加密
        RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。
        该算法有一对密钥：公钥（publickey）和私钥（privatekey）
        公钥可以公开，用于加密；私钥自己保留，用于解密。
        该算法强度复杂，加解密没有对称加密解密快。
        
    ## Base64伪加密
        # Base64是一种用64个字符来表示任意二进制数据的方法。Base64是一种
        编码方式，看上去像加密。
        # Base64使用:[A-Za-z0-9+/]这64个字符实现对数据进行加密。
        
        <html>
            <script type="text/javascript">
                // 创建Base64对象
                var Base64={...};
                // 定义字符串
                var string = "huoyijun";
                // 加密
                var encodeString = Base64.encode(string);
                alert(encodeString);
                
                // 解密
                var decodeString = Base64.decode(encodeString);
                alert(decodeString);
            </script>
        </html>


# js基本语法
    ## 数组array
        # array.join("separator") == array['join']("separator") # 数组拼接
        # array.push(element) == array['push'](element) # 数组末尾添加元素
        # array.toString() == array['toString']() # 数组转化成字符串  


# js代码在线解密工具
    ## aaencode
        将一堆类似表情符的js代码解密
        
        
# python代码中设置execjs运行环境
    os.environ["EXECJS_RUNTIME"] = "PhantomJS"


# 抓腾讯包不要用QQ浏览器，抓谁的包就不要用谁的浏览器


# 一般post参数搜索方式
    # key
    # var key
    # key=
    # key =
    # key:
    # key :


# post参数在js文件中搜不到
    ## 参数混淆
        # 参数可能以某种编码存在于js文件中  # 如Unicode编码：\u4e00-\u9fa5; 十六进制: \x61(ASCII>>a)
    
    ## 参数拼接
        # 参数在返回时可能是几个字符串拼接而成  # ["a" + "_b"]
    
    ## 可以尝试用搜JSON.parse来搜索
        # js很多返回结果在最后都要用JSON.parse来返回json数据


# post值搜不到
    # 该值是js生成的
    # 该值在协议头或cookie中


# 找cookie参数时开无痕刷新界面


# 打开浏览器source栏，跟进网页查看服务器返回的资源文件


# 定位cookie生成函数
    ## document.cookie
    ## $.cookie
    ## 匿名混淆函数，需要慢慢找
    

# 提交参数编码
    return encodeURIComponent(arg)
    
# 鬼鬼JS调试工具


# 滑块验证一般会提交版本号，优先找带版本号的js文件

# 抠js代码注意事项
    # var window = this;
    # var navigator = {} 或 this;
    # document
    # eval
    # void  # ob解混淆时可能会把void处理掉，影响某个全局变量的使用


# "Hm_"开头的cookie是浏览器自动生成的，一般服务器不会验证该cookie


# =>是es6语法中的arrow function
    ## (x) => x + 6 相当于
        # function(x){
            return x + 6;
          };

# hook某个函数
    # hook eval
        // 保存原始方法
        window.__cr_eval = window.eval;
        // 重写eval方法
        var myeval = function(src){
            console.log(src);
            console.log("=============== eval end ===============");
            debugger;
            return window.__cr_eval(src);
        }
        var _myeval = myeval.bind(null);
        // 这里主要是屏蔽js中对原生函数native属性的检测
        _myeval.toString = window.__cr_eval.toString;
        Object.defineProperty(window, 'eval', {value: _myeval});
    
    # hook Function
        window.__cr_fun = window.Function;
        var myfun = function(){
            var args = Array.prototype.slice.call(arguments, 0, -1).join(","), src = arguments[arguments.length - 1]
            console.log(src);
            console.log("=============== Function end ===============");
            debugger;
            return window.__cr_fun.apply(this, arguments);
        }
        // 这里主要是屏蔽js中对原生函数native属性的检测
        myfun.toString = function(){return window.__cr_fun + ""}
        Object.defineProperty(window, 'Function', {value: myfun});
        
        
        (function(){
            var hk_console_log = console.log;
            console.log = function(v){};
        })();
    
    
    # hook JSON.stringify、JSON.parse
        var my_stringify = JSON.stringify;
        JSON.stringify = function(params){
            console.log("hook", params);
            debugger;
            return my_stringify(params);
        };

        var my_parse = JSON.parse;
        JSON.parse = function(params){
            console.log("hook", params);
            debugger;
            return my_parse(params);
        };
    
    # hook cookie
        hook某一个cookie设置的地方

        (function(){
            var hk_document_cookie = document.cookie;
            Object.defineProperty(document, 'cookie', {
                set: function(cookie) {
                    //if(cookie.indexOf('RM4hZBv0dDon443M') != -1){
                        debugger;
                    //};
                    hk_document_cookie = cookie;
                }
            });
        })();
        
        // hook other
        (function(){
            var hk_window_CryptoJS = window.CryptoJS;
            Object.defineProperty(window, 'CryptoJS', {
                set: function(v) {
                    debugger;
                    hk_window_CryptoJS = v;
                },
                get: function(v){
                    debugger;
                    return hk_window_CryptoJS[v];
                },
            });
        })();
        
        (function(){
            var hk_window_$ss = window['_$ss'];
            Object.defineProperty(window, '_$ss', {
                set: function(v) {
                    debugger;
                    hk_window_$ss = v;
                },
                get: function(v){
                    debugger;
                    return hk_window_$ss[v];
                },
            });
        })();
        
        (function(){
            var hk_eval = eval;
            eval = function(v){
                debugger;
                return hk_eval(v);
            };
        })();
        
        (function(){
            var hook_window_url = window.url;
            var hook_document_URL = document.URL;
            var hook_document_domain = document.domain;
            
            
            Object.defineProperty(window, "url", {
                get: function(){
                    debugger;
                    return hook_window_url;
                }
            });
            Object.defineProperty(document, "URL", {
                get: function(){
                    debugger;
                    return hook_document_URL;
                }
            });
            Object.defineProperty(document, "domain", {
                get: function(){
                    debugger;
                    return hook_document_domain;
                }
            });
        })();
        
    
    # hook所有cookie
        var cookie_cache = document.cookie;
        Object.defineProperty(document, 'cookie', {
            get: function(){
                console.log('Getting cookie');
                return cookie_cache;
            },
            set: function(val){
                console.log('Setting cookie', val);
                var cookie = val.split(';')[0];
                var ncookie = cookie.split('=');
                var flag = false;
                var cache = cookie_cache.split('; ');
                cache = cache.map(function(a){
                    if (a.split('=')[0] === ncookie[0]){
                        falg = true;
                        return cookie;
                    }
                    return a;
                })
                cookie_cache = cache.join('; ');
                if(!falg){
                    cookie_cache += cookie + '; ';
                }
                this._value = val;
                return cookie_cache;
            },
        });
    
    # hook window对象
        var window_flag_1 = 'object1'; // 修改为需要hook的对象
        var window_flag_2 = 'object2'; // hook对象的对象

        var key_value_map = {};
        var window_value = window[window_flag_1];

        Object.defineProperty(window, window_flag_1, {
            get: function(){
                console.log('Getting', window, window_flag_1, '=', window_value);
                debugger;
                return window_value;
            },
            set: function(val){
                console.log('Setting', window, window_flag_1, '=', val);
                debugger;
                window_value = val;
                key_value_map[window[window_flag_1]] = window_flag_1;
                set_obj_attr(window[window_flag_1], window_flag_2);
            },
        });

        function set_obj_attr(obj, attr){
            var obj_arrt_value = obj[attr];
            Object.defineProperty(obj, attr, {
                get:function(){
                    console.log('Getting', key_value_map[obj], attr, '=', obj_arrt_value);
                    debugger;
                    return obj_arrt_value
                },
                set: function(val){
                    console.log('Setting', key_value_map[obj], attr, '=', val);
                    debugger;
                    obj_arrt_value = val;
                },
            });
        };
    
    # hook WebSocket
        WebSocket.prototype.senda = WebSocket.prototype.send;
        WebSocket.prototype.send = function(data){
            console.log('Hook WebSocket', data);
            return this.senda(data);
        };


Object.defineProperty(person,'name',{
    configurable:false,//能否使用delete、能否需改属性特性、或能否修改访问器属性、，false为不可重新定义，默认值为true
    enumerable:false,//对象属性是否可通过for-in循环，flase为不可循环，默认值为true
    writable:false,//对象属性是否可修改,flase为不可修改，默认值为true
    value:'xiaoming' //对象属性的默认值，默认值为undefined
});








